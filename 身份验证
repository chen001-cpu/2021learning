个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：
首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值：
Z：0 1 2 3 4 5 6 7 8 9 10
M：1 0 X 9 8 7 6 5 4 3 2
现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。

输入格式：
输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。

输出格式：
按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出All passed。

输入样例1：
4
320124198808240056
12010X198901011234
110108196711301866
37070419881216001X

输出样例1：
12010X198901011234
110108196711301866
37070419881216001X

输入样例2：
2
320124198808240056
110108196711301862

输出样例2：
All passed
-----------------------------------------------

#include<stdio.h>
#define size 21
int Weight(char num[size])//自定义函数算加权值Z，考虑到身份证可能含字母，用字符数组储存身份证，故而形参也是字符数组
{                 
 int t;
 t=(num[0]-'0')*7+(num[1]-'0')*9+(num[2]-'0')*10+(num[3]-'0')*5+(num[4]-'0')*8+(num[5]-'0')*4+(num[6]-'0')*2+(num[7]-'0')*1+(num[8]-'0')*6+(num[9]-'0')*3+(num[10]-'0')*7+(num[11]-'0')*9+(num[12]-'0')*10+(num[13]-'0')*5+(num[14]-'0')*8+(num[15]-'0')*4+(num[16]-'0')*2;
 t=t%11;
 return t;       //'数字'-'0'=数字，也可能出现前17位误入字母的情况，这个时候就是'字符'-'0'= ASCII码差值(数字字符也是这样，只不过正好是需要的值)
}
char Check(int n)          //自定义函数算加权结果对应的效验码M，函数返回值也是字符型，与身份证(字符型)最后一位比较
{
 char s;
 switch(n)
 {
      case 0 :s='1';break;
      case 1 :s='0';break;
      case 2 :s='X';break;
      case 3 :s='9';break;
      case 4 :s='8';break;
      case 5 :s='7';break;
      case 6 :s='6';break;
      case 7 :s='5';break;
      case 8 :s='4';break;
      case 9 :s='3';break;
      case 10:s='2';break;
 }
 return s;
}
int main()
{
 int i,j,N,error=0;
 char date[100][size]={'\0'};
 scanf("%d",&N);
 for(i=0;i<N;i++)
 {
  scanf("%s",date[i]);
  for(j=0;j<17;j++)
  {
   if(date[i][j]<'0'||date[i][j]>'9')       //如果出现前17位误入字母的情况，直接退出第一个循环(第一个身份证)
   {
    date[i][size-1]=1;                      //输入的身份证没有占完size，利用(size-1)位置标记正确和错误
    break;
   }
  }
  if(date[i][17]!=Check(Weight(date[i])))          //比较身份证第18位是否等于效验码M
  {
   date[i][size-1]=1;
  }
 }
 for(i=0;i<N;i++)
 {
  if(date[i][size-1])
  {
   printf("%s\n",date[i]);
   error++;
  }
 }
 if(!error)              //当error==0时，说明没有出现问题
 {
  printf("All passed\n");
 }
 return 0;
}
